<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TuningHub Analytics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --primary: #3498db;
      --primary-dark: #2980b9;
      --secondary: #2ecc71;
      --secondary-dark: #27ae60;
      --danger: #e74c3c;
      --warning: #f39c12;
      --info: #9b59b6;
      --dark: #2c3e50;
      --light: #ecf0f1;
      --gray: #95a5a6;
      --bg: #f9f9f9;
      --card-bg: #ffffff;
      --text: #2d3748;
      --text-light: #718096;
      --link-color: #0077cc;
      --border: #ddd;
      --shadow: 0 6px 12px rgba(0, 0, 0, 0.06);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      height: 100%;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
    }
    
    /* Header */
    .header {
      background: white;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1);
      padding: 16px;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      font-size: 1.8rem;
      font-weight: bold;
      color: var(--dark);
    }
    
    .account-erstellen img {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      transition: background 0.2s;
    }
    
    .account-erstellen:hover img {
      background: #f0f0f0;
    }
    
    /* Haupt-Layout */
    main {
      flex: 1;
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }
    
    /* Filter-Bereich */
    .filters { 
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: var(--shadow);
      margin-bottom: 2rem;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1.5rem;
      align-items: center;
      border: 1px solid var(--border);
    }
    
    .filter-group {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    select, button, input {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      font-size: 0.95rem;
      background: white;
      transition: all 0.2s;
      cursor: pointer;
    }
    
    select:focus, button:focus, input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
    }
    
    button {
      background: var(--primary);
      color: white;
      border: none;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    button:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
    }
    
    /* Dashboard Grid */
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 2rem;
    }
    
    /* Kartenstil */
    .card {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      text-align: left;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: hidden;
    }
    
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.08);
    }
    
    .card h3 {
      color: var(--dark);
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }
    
    .card-value {
      font-size: 2rem;
      font-weight: bold;
      margin: 0.5rem 0 0;
      color: var(--dark);
    }
    
    .card-change {
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }
    
    .positive {
      color: var(--secondary);
    }
    
    .negative {
      color: var(--danger);
    }
    
    /* Chart Container */
    .chart-container {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      border: 1px solid var(--border);
    }
    
    .chart-container:hover {
      box-shadow: 0 6px 12px rgba(0,0,0,0.08);
    }
    
    .chart-title {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: var(--dark);
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .chart-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .chart-action-btn {
      background: none;
      border: 1px solid #e2e8f0;
      color: var(--text-light);
      padding: 0.4rem 0.75rem;
      font-size: 0.8rem;
      border-radius: 6px;
    }
    
    .chart-action-btn:hover {
      background: #f7fafc;
      transform: none;
      box-shadow: none;
    }
    
    .chart-action-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    
    /* Tab Container */
    .tab-container {
      margin-bottom: 1.5rem;
    }
    
    .tabs {
      display: flex;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    .tab.active {
      border-bottom-color: var(--primary);
      color: var(--primary);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Grid Layouts */
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 2rem;
    }
    
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 2rem;
    }
    
    .full-width {
      grid-column: 1 / -1;
    }
    
    /* Data Table */
    .data-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    
    .data-table th, .data-table td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .data-table th {
      background: #f7fafc;
      font-weight: 600;
      color: var(--text-light);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .data-table tr:hover {
      background: #f7fafc;
    }
    
    /* Summary Stats */
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    
    .summary-stat {
      text-align: center;
      padding: 1rem;
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      border: 1px solid var(--border);
    }
    
    .summary-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--dark);
    }
    
    .summary-label {
      font-size: 0.85rem;
      color: var(--text-light);
      margin-top: 0.25rem;
    }
    
    /* Statusanzeigen */
    .loading, .error, .empty {
      grid-column: 1 / -1;
      text-align: center;
      padding: 2rem;
      background: white;
      border-radius: 12px;
      border: 1px solid var(--border);
      color: #666;
      font-size: 1.1rem;
    }
    
    .error {
      background: #f8d7da;
      color: #721c24;
      border-color: #f5c6cb;
    }
    
    .empty {
      background: #d4edda;
      color: #155724;
      border-color: #c3e6cb;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(52, 152, 219, 0.2);
      border-left: 4px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Custom Date Range */
    #customDateRange {
      display: none;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    /* Responsive Design */
    @media (max-width: 1200px) {
      .grid-3 {
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      }
    }
    
    @media (max-width: 768px) {
      .filters {
        grid-template-columns: 1fr;
      }
      
      .filter-group {
        justify-content: space-between;
      }
      
      .grid-2, .grid-3 {
        grid-template-columns: 1fr;
      }
      
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .chart-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }
      
      .summary-stats {
        grid-template-columns: 1fr;
      }
      
      .tabs {
        flex-wrap: wrap;
      }
      
      .tab {
        flex: 1;
        text-align: center;
      }
    }
  </style>
<link rel="stylesheet" href="/src/css/main.css" />
<link rel="stylesheet" href="/src/css/search.css" />
<link rel="stylesheet" href="/src/css/menu.css" />

<script src="/src/js/search.js" defer></script>
<script src="/src/js/menu.js" defer></script>

</head>
<body>
    <header class="header">
      <div class="header-top">
        <div class="logo">
          <a href="..../index.html">
            <img
              src="../../../TuningHub/public/img/THub-Logo-ohne-Hintergrund-500x200.png"
              alt="TuningHub Logo"
              height="50"
            />
          </a>
        </div>
        <div class="searchbar-wrapper">
        <input
          id="searchbar"
          type="text"
          class="searchbar"
          placeholder="Suche nach Teilen, Marken..."
        >
        <img 
        src="../../../TuningHub/public/svg/search_60dp_000000_FILL0_wght400_GRAD0_opsz48.../../../TuningHub/public/svg"
        >
        
      </div>
      
  
      <button id="menu-btn" class="menu-button" aria-controls="sidebar" aria-expanded="false" aria-label="Navigation öffnen">
  <!-- Öffnene -->
  <img src="../../../TuningHub/public/svg/menu_60dp_000000_FILL0_wght400_GRAD0_opsz48.../../../TuningHub/public/svg" alt="Menu" width="36" height="36" class="icon icon-open">
  <!-- Schließen -->
  <img src="../../../TuningHub/public/svg/close_60dp_000000_FILL0_wght400_GRAD0_opsz48.../../../TuningHub/public/svg" alt="Schließen" width="36" height="36" class="icon icon-close">
</button>
<nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">Navigation</div>
        </div>
        <div class="menu-items">
           
    </nav>
      <div class="overlay" id="overlay"></div>
    </header>

  <main>
    <div class="filters">
      <div class="filter-group">
        <div>
          <label for="timeFilter">Zeitraum: </label>
          <select id="timeFilter">
            <option value="24h">Letzte 24 Stunden</option>
            <option value="7d" selected>Letzte 7 Tage</option>
            <option value="30d">Letzte 30 Tage</option>
            <option value="90d">Letzte 90 Tage</option>
            <option value="year">Letztes Jahr</option>
            <option value="custom">Benutzerdefiniert</option>
          </select>
        </div>
        
        <div id="customDateRange">
          <label for="startDate">Von: </label>
          <input type="date" id="startDate">
          <label for="endDate">Bis: </label>
          <input type="date" id="endDate">
        </div>
        
        <div>
          <label for="dataGranularity">Granularität: </label>
          <select id="dataGranularity">
            <option value="hourly">Stündlich</option>
            <option value="daily" selected>Täglich</option>
            <option value="weekly">Wöchentlich</option>
            <option value="monthly">Monatlich</option>
          </select>
        </div>
      </div>
      
      <button id="refreshBtn">
        <span>🔄</span> Aktualisieren
      </button>
    </div>

    <div id="loading" class="loading">
      <div class="spinner"></div>
      <div>Daten werden geladen...</div>
    </div>
    
    <div id="error" class="error" style="display: none;"></div>

    <div class="dashboard-grid" id="stats" style="display: none;">
      <div class="card">
        <h3>📈 Pageviews</h3>
        <div class="card-value" id="pageviews">0</div>
        <div class="card-change" id="pageviews_change">
          <span class="positive">↑ 0%</span> vs. Vorperiode
        </div>
      </div>
      <div class="card">
        <h3>👤 Aktive Nutzer</h3>
        <div class="card-value" id="active_users">0</div>
        <div class="card-change" id="active_users_change">
          <span class="positive">↑ 0%</span> vs. Vorperiode
        </div>
      </div>
      <div class="card">
        <h3>🔐 Login-Versuche</h3>
        <div class="card-value" id="login_attempts">0</div>
        <div class="card-change" id="login_attempts_change">
          <span class="positive">↑ 0%</span> vs. Vorperiode
        </div>
      </div>
      <div class="card">
        <h3>⚙️ Neue Teile</h3>
        <div class="card-value" id="parts">0</div>
        <div class="card-change" id="parts_change">
          <span class="positive">↑ 0%</span> vs. Vorperiode
        </div>
      </div>
      <div class="card">
        <h3>💰 Ø Preis</h3>
        <div class="card-value" id="avg_price">0 €</div>
        <div class="card-change" id="avg_price_change">
          <span class="positive">↑ 0%</span> vs. Vorperiode
        </div>
      </div>
      <div class="card">
        <h3>📊 Konversion</h3>
        <div class="card-value" id="conversion_rate">0%</div>
        <div class="card-change" id="conversion_rate_change">
          <span class="positive">↑ 0%</span> vs. Vorperiode
        </div>
      </div>
    </div>

    <div class="tab-container">
      <div class="tabs">
        <div class="tab active" data-tab="overview">Übersicht</div>
        <div class="tab" data-tab="events">Events</div>
        <div class="tab" data-tab="parts">Teile</div>
        <div class="tab" data-tab="users">Nutzer</div>
      </div>
    </div>

    <div class="tab-content active" id="overview-tab">
      <div class="grid-2">
        <div class="chart-container">
          <h3 class="chart-title">
            Nutzungsstatistiken
            <div class="chart-actions">
              <button class="chart-action-btn active" data-chart-type="line">Linie</button>
              <button class="chart-action-btn" data-chart-type="bar">Balken</button>
            </div>
          </h3>
          <canvas id="eventsChart"></canvas>
        </div>
        <div class="chart-container">
          <h3 class="chart-title">
            Teile-Uploads & Preise
            <div class="chart-actions">
              <button class="chart-action-btn active" data-chart-type="combo">Kombiniert</button>
              <button class="chart-action-btn" data-chart-type="separate">Getrennt</button>
            </div>
          </h3>
          <canvas id="partsChart"></canvas>
        </div>
      </div>
      
      <div class="grid-3">
        <div class="chart-container">
          <h3 class="chart-title">Event-Verteilung</h3>
          <canvas id="eventsPieChart"></canvas>
        </div>
        <div class="chart-container">
          <h3 class="chart-title">Nutzeraktivität</h3>
          <canvas id="userActivityChart"></canvas>
        </div>
        <div class="chart-container">
          <h3 class="chart-title">Preisverteilung</h3>
          <canvas id="priceDistributionChart"></canvas>
        </div>
      </div>
    </div>

    <div class="tab-content" id="events-tab">
      <div class="chart-container full-width">
        <h3 class="chart-title">Detaillierte Event-Analyse</h3>
        <canvas id="detailedEventsChart" height="100"></canvas>
      </div>
      
      <div class="grid-2">
        <div class="chart-container">
          <h3 class="chart-title">Events nach Typ</h3>
          <canvas id="eventsByTypeChart"></canvas>
        </div>
        <div class="chart-container">
          <h3 class="chart-title">Event-Trends</h3>
          <canvas id="eventTrendsChart"></canvas>
        </div>
      </div>
    </div>

    <div class="tab-content" id="parts-tab">
      <div class="summary-stats">
        <div class="summary-stat">
          <div class="summary-value" id="totalPartsValue">0 €</div>
          <div class="summary-label">Gesamtwert aller Teile</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value" id="maxPartPrice">0 €</div>
          <div class="summary-label">Höchster Einzelpreis</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value" id="partsPerDay">0</div>
          <div class="summary-label">Ø Teile pro Tag</div>
        </div>
      </div>
      
      <div class="chart-container full-width">
        <h3 class="chart-title">Teile-Übersicht</h3>
        <div class="data-table-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Erstellt am</th>
                <th>Preis (€)</th>
                <th>Kategorie</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="partsTableBody">
              <!-- Wird mit JavaScript befüllt -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="tab-content" id="users-tab">
      <div class="grid-2">
        <div class="chart-container">
          <h3 class="chart-title">Nutzeraktivität nach Tageszeit</h3>
          <canvas id="userTimeChart"></canvas>
        </div>
        <div class="chart-container">
          <h3 class="chart-title">Nutzer-Segmentierung</h3>
          <canvas id="userSegmentationChart"></canvas>
        </div>
      </div>
    </div>
  </main>
  <footer>
    <div class="informations"><a href="/src/pages/übertuninghub.html">TuningHub</a></div>
    <div class="informations"><a href="/src/pages/impressum.html">Impressum</a></div>
    <div class="informations"><a href="/src/pages/support.html">Support</a></div>
    <div class="informations"><a href="/src/pages/socialmedia.html">Social Media</a></div>
    <div class="informations"><a href="/src/pages/agb.html">AGB</a></div>
    <div class="informations"><a href="/src/pages/haftungsbeschränkung.html">Haftungsbeschränkung</a></div>
    <div class="informations"><a href="/src/pages/datenschutz.html">Datenschutz</a></div>
  </footer>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    // Mock-Daten für den Fall, dass die Supabase-Verbindung fehlschlägt
    const generateMockEvents = (days = 7) => {
      const events = [];
      const eventTypes = ['pageview', 'login_attempt', 'search', 'part_view'];
      const users = ['user1', 'user2', 'user3', 'user4', 'user5'];
      
      for (let i = 0; i < days; i++) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        
        // 5-20 Events pro Tag
        const eventsPerDay = Math.floor(Math.random() * 15) + 5;
        
        for (let j = 0; j < eventsPerDay; j++) {
          const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
          const user = users[Math.floor(Math.random() * users.length)];
          const timestamp = new Date(date);
          timestamp.setHours(Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
          
          events.push({
            id: `event-${i}-${j}`,
            event_type: eventType,
            user_id: user,
            timestamp: timestamp.toISOString()
          });
        }
      }
      
      return events;
    };

    const generateMockParts = (days = 7) => {
      const parts = [];
      const categories = ['Motor', 'Karosserie', 'Fahrwerk', 'Elektronik', 'Innenraum'];
      const statuses = ['Aktiv', 'Verkauft', 'Reserviert'];
      
      for (let i = 0; i < days; i++) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        
        // 1-5 Teile pro Tag
        const partsPerDay = Math.floor(Math.random() * 4) + 1;
        
        for (let j = 0; j < partsPerDay; j++) {
          const category = categories[Math.floor(Math.random() * categories.length)];
          const status = statuses[Math.floor(Math.random() * statuses.length)];
          const price = (Math.random() * 1000 + 10).toFixed(2);
          
          parts.push({
            id: `part-${i}-${j}`,
            created_at: date.toISOString(),
            price: price,
            category: category,
            status: status
          });
        }
      }
      
      return parts;
    };

    // Supabase-Clients
    const tracking = createClient(
      'https://lhxcnrogjjskgaclqxtm.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxoeGNucm9nampza2dhY2xxeHRtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI1MjU0MzUsImV4cCI6MjA2ODEwMTQzNX0.vOr_Esi9IIesFixkkvYQjYEqghrKCMeqbrPKW27zqww'
    )

    const supabase = createClient(
      'https://yvdptnkmgfxkrszitweo.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl2ZHB0bmttZ2Z4a3Jzeml0d2VvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA3MDAwMzQsImV4cCI6MjA2NjI3NjAzNH0.Kd6D6IQ_stUMrcbm2TN-7ACjFJvXNmkeNehQHavTmJo'
    )

    // DOM-Elemente
    const timeSelect = document.getElementById('timeFilter')
    const granularitySelect = document.getElementById('dataGranularity')
    const refreshBtn = document.getElementById('refreshBtn')
    const customDateRange = document.getElementById('customDateRange')
    const startDateInput = document.getElementById('startDate')
    const endDateInput = document.getElementById('endDate')
    
    const eventsChartCanvas = document.getElementById('eventsChart')
    const partsChartCanvas = document.getElementById('partsChart')
    const eventsPieChartCanvas = document.getElementById('eventsPieChart')
    const userActivityChartCanvas = document.getElementById('userActivityChart')
    const priceDistributionChartCanvas = document.getElementById('priceDistributionChart')
    const detailedEventsChartCanvas = document.getElementById('detailedEventsChart')
    const eventsByTypeChartCanvas = document.getElementById('eventsByTypeChart')
    const eventTrendsChartCanvas = document.getElementById('eventTrendsChart')
    const userTimeChartCanvas = document.getElementById('userTimeChart')
    const userSegmentationChartCanvas = document.getElementById('userSegmentationChart')
    
    const loadingElement = document.getElementById('loading')
    const errorElement = document.getElementById('error')
    const statsElement = document.getElementById('stats')
    const partsTableBody = document.getElementById('partsTableBody')
    
    // Chart-Instanzen
    let eventsChart = null
    let partsChart = null
    let eventsPieChart = null
    let userActivityChart = null
    let priceDistributionChart = null
    let detailedEventsChart = null
    let eventsByTypeChart = null
    let eventTrendsChart = null
    let userTimeChart = null
    let userSegmentationChart = null

    // Event Listener
    timeSelect.addEventListener('change', function() {
      if (this.value === 'custom') {
        customDateRange.style.display = 'flex'
        // Standardwerte setzen: letzte 7 Tage
        const end = new Date()
        const start = new Date()
        start.setDate(end.getDate() - 7)
        
        startDateInput.value = start.toISOString().split('T')[0]
        endDateInput.value = end.toISOString().split('T')[0]
      } else {
        customDateRange.style.display = 'none'
      }
      loadData()
    })
    
    granularitySelect.addEventListener('change', loadData)
    refreshBtn.addEventListener('click', loadData)
    
    // Tab-Funktionalität
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Aktiven Tab markieren
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'))
        this.classList.add('active')
        
        // Tab-Inhalt anzeigen
        const tabId = this.getAttribute('data-tab')
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active')
        })
        document.getElementById(`${tabId}-tab`).classList.add('active')
      })
    })
    
    // Chart-Type-Buttons
    document.querySelectorAll('.chart-action-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const parent = this.parentElement
        const chartType = this.getAttribute('data-chart-type')
        
        // Nur einen Button als aktiv markieren
        parent.querySelectorAll('.chart-action-btn').forEach(b => b.classList.remove('active'))
        this.classList.add('active')
        
        // Chart neu zeichnen mit neuem Typ
        if (this.closest('.chart-container').querySelector('#eventsChart')) {
          // Events Chart
          createEventsChart(currentEventsData, currentStartDate, currentEndDate, chartType)
        } else if (this.closest('.chart-container').querySelector('#partsChart')) {
          // Parts Chart
          createPartsChart(currentPartsData, currentStartDate, currentEndDate, chartType)
        }
      })
    })

    // Initialer Datenabruf
    loadData()

// Daten für spätere Verwendung speichern
    let currentEventsData = []
    let currentPartsData = []
    let currentStartDate = null
    let currentEndDate = null

    // Initialer Datenabruf
    loadData()

    function getDateRange(filter) {
      const now = new Date()
      const start = new Date(now)
      
      switch (filter) {
        case '24h': 
          start.setHours(now.getHours() - 24)
          break
        case '7d':
          start.setDate(now.getDate() - 7)
          break
        case '30d':
          start.setDate(now.getDate() - 30)
          break
        case '90d':
          start.setDate(now.getDate() - 90)
          break
        case 'year':
          start.setFullYear(now.getFullYear() - 1)
          break
        case 'custom':
          // Verwende die benutzerdefinierten Daten
          if (startDateInput.value && endDateInput.value) {
            return {
              start: new Date(startDateInput.value),
              end: new Date(endDateInput.value)
            }
          }
          // Fallback: letzte 7 Tage
          start.setDate(now.getDate() - 7)
          break
      }
      
      return { start, end: now }
    }
    
    function getPreviousPeriodDateRange(start, end) {
      const periodLength = end - start
      return {
        start: new Date(start.getTime() - periodLength),
        end: new Date(end.getTime() - periodLength)
      }
    }

    async function loadData() {
      try {
        // UI zurücksetzen
        loadingElement.style.display = 'flex'
        errorElement.style.display = 'none'
        statsElement.style.display = 'none'
        
      // Alte Charts zerstören
        const charts = [eventsChart, partsChart, eventsPieChart, userActivityChart, 
         priceDistributionChart, detailedEventsChart, eventsByTypeChart,
         eventTrendsChart, userTimeChart, userSegmentationChart];
        
        charts.forEach(chart => {
          if (chart && typeof chart.destroy === 'function') {
            try {
              chart.destroy();
            } catch (e) {
              console.warn('Fehler beim Zerstören eines Charts:', e);
            }
          }
        })

        const { start, end } = getDateRange(timeSelect.value)
        currentStartDate = start
        currentEndDate = end
        
        // Vorperiode für Vergleich berechnen
        const previousPeriod = getPreviousPeriodDateRange(start, end)
        
        const todayStart = new Date()
        todayStart.setHours(0, 0, 0, 0)

        let parts = []
        let events = []
        let previousParts = []
        let previousEvents = []

        try {
          // Parallele Abfragen an beide Supabase-Instanzen
          const [
            partsResult,
            eventsResult,
            previousPartsResult,
            previousEventsResult
          ] = await Promise.allSettled([
            supabase.from('parts')
              .select('*')
              .gte('created_at', start.toISOString())
              .lte('created_at', end.toISOString()),
            tracking.from('tracking_events')
              .select('*')
              .gte('timestamp', start.toISOString())
              .lte('timestamp', end.toISOString()),
            supabase.from('parts')
              .select('*')
              .gte('created_at', previousPeriod.start.toISOString())
              .lte('created_at', previousPeriod.end.toISOString()),
            tracking.from('tracking_events')
              .select('*')
              .gte('timestamp', previousPeriod.start.toISOString())
              .lte('timestamp', previousPeriod.end.toISOString())
          ])

          // Daten aus den Ergebnissen extrahieren mit Fallbacks
          parts = partsResult.status === 'fulfilled' && partsResult.value.data ? partsResult.value.data : generateMockParts(7);
          events = eventsResult.status === 'fulfilled' && eventsResult.value.data ? eventsResult.value.data : generateMockEvents(7);
          previousParts = previousPartsResult.status === 'fulfilled' && previousPartsResult.value.data ? previousPartsResult.value.data : generateMockParts(7);
          previousEvents = previousEventsResult.status === 'fulfilled' && previousEventsResult.value.data ? previousEventsResult.value.data : generateMockEvents(7);

          // Fehler protokollieren, aber nicht werfen
          if (partsResult.status === 'rejected') console.error('Teile-Daten Fehler:', partsResult.reason);
          if (eventsResult.status === 'rejected') console.error('Tracking-Daten Fehler:', eventsResult.reason);
        } catch (error) {
          console.error('Fehler bei API-Abfragen:', error);
          // Fallback zu Mock-Daten
          parts = generateMockParts(7);
          events = generateMockEvents(7);
          previousParts = generateMockParts(7);
          previousEvents = generateMockEvents(7);
        }

        // Sicherstellen, dass alle Daten Arrays sind
        if (!Array.isArray(parts)) parts = generateMockParts(7);
        if (!Array.isArray(events)) events = generateMockEvents(7);
        if (!Array.isArray(previousParts)) previousParts = generateMockParts(7);
        if (!Array.isArray(previousEvents)) previousEvents = generateMockEvents(7);

        // Daten für spätere Verwendung speichern
        currentEventsData = events
        currentPartsData = parts
        
        // Heutige Events filtern
        const todaysEvents = events.filter(e => e && e.timestamp && new Date(e.timestamp) >= todayStart)

        // Eindeutige Nutzer identifizieren
        const activeUsers = new Set(
          events
            .map(e => e && e.user_id ? e.user_id : null)
            .filter(id => id && id !== 'undefined')
        )
        
        const previousActiveUsers = new Set(
          previousEvents
            .map(e => e && e.user_id ? e.user_id : null)
            .filter(id => id && id !== 'undefined')
        )

        // Statistiken berechnen
        const pageviews = events.filter(e => e && e.event_type === 'pageview').length
        const previousPageviews = previousEvents.filter(e => e && e.event_type === 'pageview').length
        
        const loginAttempts = events.filter(e => e && e.event_type === 'login_attempt').length
        const previousLoginAttempts = previousEvents.filter(e => e && e.event_type === 'login_attempt').length
        
        // Durchschnittspreis berechnen
        const validParts = parts.filter(p => p && p.price);
        const avgPrice = validParts.length > 0 
          ? (validParts.reduce((sum, part) => sum + parseFloat(part.price), 0) / validParts.length).toFixed(2)
          : 0
        
        const previousValidParts = previousParts.filter(p => p && p.price);
        const previousAvgPrice = previousValidParts.length > 0 
          ? (previousValidParts.reduce((sum, part) => sum + parseFloat(part.price), 0) / previousValidParts.length).toFixed(2)
          : 0
        
        // Konversionsrate berechnen (Annahme: Login nach Pageview)
        const uniquePageviewUsers = new Set(
          events
            .filter(e => e && e.event_type === 'pageview')
            .map(e => e.user_id)
            .filter(id => id)
        )
        const uniqueLoginUsers = new Set(
          events
            .filter(e => e && e.event_type === 'login_attempt')
            .map(e => e.user_id)
            .filter(id => id)
        )
        
        const conversionRate = uniquePageviewUsers.size > 0 
          ? ((uniqueLoginUsers.size / uniquePageviewUsers.size) * 100).toFixed(1)
          : 0
        
        // Veränderungen berechnen
        const pageviewsChange = previousPageviews > 0 
          ? (((pageviews - previousPageviews) / previousPageviews) * 100).toFixed(1)
          : pageviews > 0 ? 100 : 0
        
        const activeUsersChange = previousActiveUsers.size > 0
          ? (((activeUsers.size - previousActiveUsers.size) / previousActiveUsers.size) * 100).toFixed(1)
          : activeUsers.size > 0 ? 100 : 0
        
        const loginAttemptsChange = previousLoginAttempts > 0
          ? (((loginAttempts - previousLoginAttempts) / previousLoginAttempts) * 100).toFixed(1)
          : loginAttempts > 0 ? 100 : 0
        
        const partsChange = previousParts.length > 0
          ? (((parts.length - previousParts.length) / previousParts.length) * 100).toFixed(1)
          : parts.length > 0 ? 100 : 0
        
        const avgPriceChange = previousAvgPrice > 0
          ? (((avgPrice - previousAvgPrice) / previousAvgPrice) * 100).toFixed(1)
          : avgPrice > 0 ? 100 : 0

        // UI aktualisieren
        document.getElementById('pageviews').textContent = pageviews.toLocaleString()
        document.getElementById('login_attempts').textContent = loginAttempts.toLocaleString()
        document.getElementById('parts').textContent = parts.length.toLocaleString()
        document.getElementById('active_users').textContent = activeUsers.size.toLocaleString()
        document.getElementById('avg_price').textContent = `${avgPrice} €`
        document.getElementById('conversion_rate').textContent = `${conversionRate}%`
        
        // Veränderungen anzeigen
        updateChangeIndicator('pageviews_change', pageviewsChange)
        updateChangeIndicator('active_users_change', activeUsersChange)
        updateChangeIndicator('login_attempts_change', loginAttemptsChange)
        updateChangeIndicator('parts_change', partsChange)
        updateChangeIndicator('avg_price_change', avgPriceChange)
        
        // Zusätzliche Parts-Statistiken
        const totalPartsValue = validParts.reduce((sum, part) => sum + parseFloat(part.price), 0)
        const maxPartPrice = validParts.length > 0 ? Math.max(...validParts.map(p => parseFloat(p.price))) : 0
        const daysInRange = Math.ceil((end - start) / (1000 * 60 * 60 * 24))
        const partsPerDay = (parts.length / daysInRange).toFixed(1)
        
        document.getElementById('totalPartsValue').textContent = `${totalPartsValue.toFixed(2)} €`
        document.getElementById('maxPartPrice').textContent = `${maxPartPrice.toFixed(2)} €`
        document.getElementById('partsPerDay').textContent = partsPerDay
        
        // Parts-Tabelle befüllen
        updatePartsTable(parts)

        // Charts erstellen
        createEventsChart(events, start, end)
        createPartsChart(parts, start, end)
        createEventsPieChart(events)
        createUserActivityChart(events, start, end)
        createPriceDistributionChart(parts)
        createDetailedEventsChart(events, start, end)
        createEventsByTypeChart(events)
        createEventTrendsChart(events, start, end)
        createUserTimeChart(events)
        createUserSegmentationChart(events)

        // UI anzeigen
        loadingElement.style.display = 'none'
        statsElement.style.display = 'grid'

      } catch (error) {
        console.error('Fehler beim Laden der Daten:', error)
        loadingElement.style.display = 'none'
        errorElement.style.display = 'block'
        errorElement.textContent = `Fehler: ${error.message}`
      }
    }
    
    function updateChangeIndicator(elementId, change) {
      const element = document.getElementById(elementId)
      const changeValue = parseFloat(change)
      
      if (changeValue > 0) {
        element.innerHTML = `<span class="positive">↑ ${change}%</span> vs. Vorperiode`
      } else if (changeValue < 0) {
        element.innerHTML = `<span class="negative">↓ ${Math.abs(change)}%</span> vs. Vorperiode`
      } else {
        element.innerHTML = `<span>→ ${change}%</span> vs. Vorperiode`
      }
    }
    
    function updatePartsTable(parts) {
      // Tabelle leeren
      partsTableBody.innerHTML = ''
      
      // Nur die neuesten 10 Teile anzeigen
      const recentParts = parts
        .filter(p => p && p.created_at)
        .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
        .slice(0, 10)
      
      recentParts.forEach(part => {
        const row = document.createElement('tr')
        
        // Datum formatieren
        const date = new Date(part.created_at)
        const formattedDate = date.toLocaleDateString('de-DE')
        
        // Preis formatieren
        const price = parseFloat(part.price || 0).toFixed(2)
        
        row.innerHTML = `
          <td>${part.id ? part.id.substring(0, 8) + '...' : 'N/A'}</td>
          <td>${formattedDate}</td>
          <td>${price} €</td>
          <td>${part.category || 'N/A'}</td>
          <td>${part.status || 'Aktiv'}</td>
        `
        
        partsTableBody.appendChild(row)
      })
    }

    function createEventsChart(events, startDate, endDate, chartType = 'line') {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Daten gruppieren basierend auf Granularität
      const granularity = granularitySelect.value
      const eventsByTime = groupDataByTime(events, 'timestamp', startDate, endDate, granularity)
      
      const isLineChart = chartType === 'line'
      
      eventsChart = new Chart(eventsChartCanvas, {
        type: isLineChart ? 'line' : 'bar',
        data: {
          labels: Object.keys(eventsByTime),
          datasets: [
            {
              label: 'Pageviews',
              data: Object.values(eventsByTime).map(period => 
                period.filter(e => e && e.event_type === 'pageview').length
              ),
              borderColor: '#3498db',
              backgroundColor: isLineChart ? 'rgba(52, 152, 219, 0.1)' : 'rgba(52, 152, 219, 0.7)',
              borderWidth: 2,
              tension: 0.1,
              fill: isLineChart
            },
            {
              label: 'Login-Versuche',
              data: Object.values(eventsByTime).map(period => 
                period.filter(e => e && e.event_type === 'login_attempt').length
              ),
              borderColor: '#e74c3c',
              backgroundColor: isLineChart ? 'rgba(231, 76, 60, 0.1)' : 'rgba(231, 76, 60, 0.7)',
              borderWidth: 2,
              tension: 0.1,
              fill: isLineChart
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            },
            tooltip: {
              mode: 'index',
              intersect: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl Events'
              }
            },
            x: {
              title: {
                display: true,
                text: getTimeAxisLabel(granularity)
              }
            }
          }
        }
      })
    }

    function createPartsChart(parts, startDate, endDate, chartType = 'combo') {
      // Sicherstellen, dass parts ein Array ist
      if (!Array.isArray(parts)) {
        console.warn('Parts ist kein Array:', parts);
        parts = [];
      }
      
      // Daten gruppieren basierend auf Granularität
      const granularity = granularitySelect.value
      const partsByTime = groupDataByTime(parts, 'created_at', startDate, endDate, granularity)
      
      // Durchschnittspreis pro Zeitraum berechnen
      const avgPriceByTime = {}
      Object.entries(partsByTime).forEach(([time, timeParts]) => {
        const validParts = timeParts.filter(p => p && p.price);
        const prices = validParts.map(p => parseFloat(p.price || 0))
        avgPriceByTime[time] = prices.length > 0 ? 
          (prices.reduce((a, b) => a + b, 0) / prices.length) : 0
      })
      
      const isComboChart = chartType === 'combo'
      
      partsChart = new Chart(partsChartCanvas, {
        type: isComboChart ? 'bar' : 'line',
        data: {
          labels: Object.keys(partsByTime),
          datasets: [
            {
              label: 'Anzahl Uploads',
              data: Object.values(partsByTime).map(time => time.length),
              backgroundColor: isComboChart ? 'rgba(46, 204, 113, 0.7)' : 'rgba(46, 204, 113, 0.1)',
              borderColor: 'rgba(39, 174, 96, 1)',
              borderWidth: isComboChart ? 1 : 2,
              yAxisID: 'y',
              order: isComboChart ? 2 : 1
            },
            {
              label: 'Ø Preis (€)',
              data: Object.values(avgPriceByTime),
              borderColor: '#f39c12',
              backgroundColor: isComboChart ? 'rgba(243, 156, 18, 0.1)' : 'rgba(243, 156, 18, 0.7)',
              borderWidth: 2,
              type: isComboChart ? 'line' : 'bar',
              yAxisID: isComboChart ? 'y1' : 'y',
              order: isComboChart ? 1 : 2,
              tension: 0.1,
              fill: !isComboChart
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            }
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: isComboChart ? 'Anzahl Uploads' : 'Wert'
              }
            },
            ...(isComboChart && {
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                title: {
                  display: true,
                  text: 'Durchschnittspreis (€)'
                },
                grid: {
                  drawOnChartArea: false
                }
              }
            }),
            x: {
              title: {
                display: true,
                text: getTimeAxisLabel(granularity)
              }
            }
          }
        }
      })
    }
    
    function createEventsPieChart(events) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Events nach Typ gruppieren
      const eventsByType = {}
      events.forEach(event => {
        if (!event) return;
        const type = event.event_type || 'unknown'
        eventsByType[type] = (eventsByType[type] || 0) + 1
      })
      
      // Farben für die verschiedenen Event-Typen
      const colors = {
        pageview: '#3498db',
        login_attempt: '#e74c3c',
        search: '#9b59b6',
        part_view: '#2ecc71',
        purchase: '#f39c12',
        unknown: '#95a5a6'
      }
      
      eventsPieChart = new Chart(eventsPieChartCanvas, {
        type: 'doughnut',
        data: {
          labels: Object.keys(eventsByType).map(key => 
            key === 'pageview' ? 'Pageviews' : 
            key === 'login_attempt' ? 'Login-Versuche' : 
            key === 'search' ? 'Suchen' : 
            key === 'part_view' ? 'Teile-Ansichten' : 
            key === 'purchase' ? 'Käufe' : 
            'Andere'
          ),
          datasets: [{
            data: Object.values(eventsByType),
            backgroundColor: Object.keys(eventsByType).map(key => colors[key] || colors.unknown),
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'bottom'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0)
                  const value = context.raw
                  const percentage = Math.round((value / total) * 100)
                  return `${context.label}: ${value} (${percentage}%)`
                }
              }
            }
          }
        }
      })
    }
    
    function createUserActivityChart(events, startDate, endDate) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Nutzeraktivität über die Zeit
      const granularity = granularitySelect.value
      const eventsByTime = groupDataByTime(events, 'timestamp', startDate, endDate, granularity)
      
      // Eindeutige Nutzer pro Zeitraum
      const uniqueUsersByTime = {}
      Object.entries(eventsByTime).forEach(([time, timeEvents]) => {
        const users = new Set(
          timeEvents
            .map(e => e && e.user_id ? e.user_id : null)
            .filter(id => id && id !== 'undefined')
        )
        uniqueUsersByTime[time] = users.size
      })
      
      userActivityChart = new Chart(userActivityChartCanvas, {
        type: 'line',
        data: {
          labels: Object.keys(eventsByTime),
          datasets: [
            {
              label: 'Aktive Nutzer',
              data: Object.values(uniqueUsersByTime),
              borderColor: '#9b59b6',
              backgroundColor: 'rgba(155, 89, 182, 0.1)',
              borderWidth: 2,
              tension: 0.1,
              fill: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl Nutzer'
              }
            },
            x: {
              title: {
                display: true,
                text: getTimeAxisLabel(granularity)
              }
            }
          }
        }
      })
    }
    
    function createPriceDistributionChart(parts) {
      // Sicherstellen, dass parts ein Array ist
      if (!Array.isArray(parts)) {
        console.warn('Parts ist kein Array:', parts);
        parts = [];
      }
      
      // Preisverteilung in Bereichen gruppieren
      const priceRanges = {
        '0-50': 0,
        '50-100': 0,
        '100-200': 0,
        '200-500': 0,
        '500-1000': 0,
        '1000+': 0
      }
      
      parts.forEach(part => {
        if (!part || !part.price) return;
        const price = parseFloat(part.price || 0)
        if (price <= 50) priceRanges['0-50']++
        else if (price <= 100) priceRanges['50-100']++
        else if (price <= 200) priceRanges['100-200']++
        else if (price <= 500) priceRanges['200-500']++
        else if (price <= 1000) priceRanges['500-1000']++
        else priceRanges['1000+']++
      })
      
      priceDistributionChart = new Chart(priceDistributionChartCanvas, {
        type: 'bar',
        data: {
          labels: Object.keys(priceRanges).map(range => `${range} €`),
          datasets: [{
            label: 'Anzahl Teile',
            data: Object.values(priceRanges),
            backgroundColor: 'rgba(52, 152, 219, 0.7)',
            borderColor: 'rgba(41, 128, 185, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl Teile'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Preisbereiche'
              }
            }
          }
        }
      })
    }
    
    function createDetailedEventsChart(events, startDate, endDate) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Detaillierte Event-Analyse mit allen Event-Typen
      const granularity = granularitySelect.value
      const eventsByTime = groupDataByTime(events, 'timestamp', startDate, endDate, granularity)
      
      // Alle Event-Typen identifizieren
      const eventTypes = [...new Set(events.map(e => e && e.event_type ? e.event_type : 'unknown'))].filter(type => type)
      
      // Farbpalette für Event-Typen
      const colorPalette = [
        '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', 
        '#1abc9c', '#d35400', '#c0392b', '#8e44ad', '#16a085'
      ]
      
      const datasets = eventTypes.map((type, index) => {
        return {
          label: type === 'pageview' ? 'Pageviews' : 
                 type === 'login_attempt' ? 'Login-Versuche' : 
                 type === 'search' ? 'Suchen' : 
                 type === 'part_view' ? 'Teile-Ansichten' : 
                 type === 'purchase' ? 'Käufe' : type,
          data: Object.values(eventsByTime).map(period => 
            period.filter(e => e && e.event_type === type).length
          ),
          borderColor: colorPalette[index % colorPalette.length],
          backgroundColor: `rgba(${hexToRgb(colorPalette[index % colorPalette.length])}, 0.1)`,
          borderWidth: 2,
          tension: 0.1,
          fill: true
        }
      })
      
      detailedEventsChart = new Chart(detailedEventsChartCanvas, {
        type: 'line',
        data: {
          labels: Object.keys(eventsByTime),
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            },
            tooltip: {
              mode: 'index',
              intersect: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl Events'
              }
            },
            x: {
              title: {
                display: true,
                text: getTimeAxisLabel(granularity)
              }
            }
          }
        }
      })
    }
    
    function createEventsByTypeChart(events) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Events nach Typ als Balkendiagramm
      const eventsByType = {}
      events.forEach(event => {
        if (!event) return;
        const type = event.event_type || 'unknown'
        eventsByType[type] = (eventsByType[type] || 0) + 1
      })
      
      // Farben für die verschiedenen Event-Typen
      const colors = {
        pageview: '#3498db',
        login_attempt: '#e74c3c',
        search: '#9b59b6',
        part_view: '#2ecc71',
        purchase: '#f39c12',
        unknown: '#95a5a6'
      }
      
      eventsByTypeChart = new Chart(eventsByTypeChartCanvas, {
        type: 'bar',
        data: {
          labels: Object.keys(eventsByType).map(key => 
            key === 'pageview' ? 'Pageviews' : 
            key === 'login_attempt' ? 'Login-Versuche' : 
            key === 'search' ? 'Suchen' : 
            key === 'part_view' ? 'Teile-Ansichten' : 
            key === 'purchase' ? 'Käufe' : 
            'Andere'
          ),
          datasets: [{
            label: 'Anzahl Events',
            data: Object.values(eventsByType),
            backgroundColor: Object.keys(eventsByType).map(key => colors[key] || colors.unknown),
            borderColor: Object.keys(eventsByType).map(key => darkenColor(colors[key] || colors.unknown)),
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl Events'
              }
            }
          }
        }
      })
    }
    
    function createEventTrendsChart(events, startDate, endDate) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Event-Trends als prozentuale Veränderung
      const granularity = granularitySelect.value
      const eventsByTime = groupDataByTime(events, 'timestamp', startDate, endDate, granularity)
      
      // Wichtige Event-Typen
      const importantEventTypes = ['pageview', 'login_attempt', 'search', 'part_view']
      
      // Berechne prozentuale Veränderung für jeden Event-Typ
      const timePeriods = Object.keys(eventsByTime)
      const datasets = importantEventTypes.map((type, index) => {
        const values = Object.values(eventsByTime).map(period => 
          period.filter(e => e && e.event_type === type).length
        )
        
        // Berechne prozentuale Veränderung zwischen aufeinanderfolgenden Zeiträumen
        const changes = values.map((value, i) => {
          if (i === 0) return 0
          const prevValue = values[i-1]
          return prevValue > 0 ? ((value - prevValue) / prevValue) * 100 : 0
        })
        
        return {
          label: type === 'pageview' ? 'Pageviews' : 
                 type === 'login_attempt' ? 'Login-Versuche' : 
                 type === 'search' ? 'Suchen' : 
                 type === 'part_view' ? 'Teile-Ansichten' : type,
          data: changes,
          borderColor: ['#3498db', '#e74c3c', '#9b59b6', '#2ecc71'][index],
          backgroundColor: `rgba(${hexToRgb(['#3498db', '#e74c3c', '#9b59b6', '#2ecc71'][index])}, 0.1)`,
          borderWidth: 2,
          tension: 0.1,
          fill: true
        }
      })
      
      // Erste Periode entfernen (keine Veränderung berechenbar)
      const labels = timePeriods.slice(1)
      
      eventTrendsChart = new Chart(eventTrendsChartCanvas, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.dataset.label}: ${context.raw.toFixed(1)}%`
                }
              }
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: 'Veränderung (%)'
              }
            },
            x: {
              title: {
                display: true,
                text: getTimeAxisLabel(granularity)
              }
            }
          }
        }
      })
    }
    
    function createUserTimeChart(events) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Nutzeraktivität nach Tageszeit
      const hours = Array.from({length: 24}, (_, i) => i)
      const activityByHour = Array(24).fill(0)
      
      events.forEach(event => {
        if (!event || !event.timestamp) return;
        const date = new Date(event.timestamp)
        const hour = date.getHours()
        activityByHour[hour]++
      })
      
      userTimeChart = new Chart(userTimeChartCanvas, {
        type: 'bar',
        data: {
          labels: hours.map(h => `${h}:00`),
          datasets: [{
            label: 'Aktivität',
            data: activityByHour,
            backgroundColor: 'rgba(52, 152, 219, 0.7)',
            borderColor: 'rgba(41, 128, 185, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl Events'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Tageszeit'
              }
            }
          }
        }
      })
    }
    
    function createUserSegmentationChart(events) {
      // Sicherstellen, dass events ein Array ist
      if (!Array.isArray(events)) {
        console.warn('Events ist kein Array:', events);
        events = [];
      }
      
      // Nutzer nach Aktivität segmentieren
      const userActivity = {}
      
      events.forEach(event => {
        if (!event || !event.user_id || event.user_id === 'undefined') return
        
        if (!userActivity[event.user_id]) {
          userActivity[event.user_id] = 0
        }
        userActivity[event.user_id]++
      })
      
      // Segmentiere Nutzer nach Aktivitätslevel
      const segments = {
        'Sehr hoch (50+ Events)': 0,
        'Hoch (20-49 Events)': 0,
        'Mittel (5-19 Events)': 0,
        'Niedrig (1-4 Events)': 0
      }
      
      Object.values(userActivity).forEach(activity => {
        if (activity >= 50) segments['Sehr hoch (50+ Events)']++
        else if (activity >= 20) segments['Hoch (20-49 Events)']++
        else if (activity >= 5) segments['Mittel (5-19 Events)']++
        else segments['Niedrig (1-4 Events)']++
      })
      
      userSegmentationChart = new Chart(userSegmentationChartCanvas, {
        type: 'pie',
        data: {
          labels: Object.keys(segments),
          datasets: [{
            data: Object.values(segments),
            backgroundColor: [
              '#3498db',
              '#2ecc71',
              '#f39c12',
              '#e74c3c'
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'bottom'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0)
                  const value = context.raw
                  const percentage = Math.round((value / total) * 100)
                  return `${context.label}: ${value} (${percentage}%)`
                }
              }
            }
          }
        }
      })
    }

    function groupDataByTime(data, dateField, startDate, endDate, granularity) {
      const result = {}
      const currentDate = new Date(startDate)
      
      // Zeiträume initialisieren basierend auf Granularität
      while (currentDate <= endDate) {
        let timeKey
        const dateStr = currentDate.toISOString().split('T')[0]
        
        switch (granularity) {
          case 'hourly':
            timeKey = `${dateStr} ${currentDate.getHours()}:00`
            currentDate.setHours(currentDate.getHours() + 1)
            break
          case 'daily':
            timeKey = dateStr
            currentDate.setDate(currentDate.getDate() + 1)
            break
          case 'weekly':
            // Ersten Tag der Woche finden
            const weekStart = new Date(currentDate)
            weekStart.setDate(currentDate.getDate() - currentDate.getDay())
            timeKey = weekStart.toISOString().split('T')[0]
            currentDate.setDate(currentDate.getDate() + 7)
            break
          case 'monthly':
            timeKey = `${currentDate.getFullYear()}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}`
            currentDate.setMonth(currentDate.getMonth() + 1)
            break
          default:
            timeKey = dateStr
            currentDate.setDate(currentDate.getDate() + 1)
        }
        
        result[timeKey] = []
      }
      
      // Daten zuordnen
      data.forEach(item => {
        if (!item || !item[dateField]) return;
        
        const itemDate = new Date(item[dateField])
        let timeKey
        
        switch (granularity) {
          case 'hourly':
            timeKey = `${itemDate.toISOString().split('T')[0]} ${itemDate.getHours()}:00`
            break
          case 'daily':
            timeKey = itemDate.toISOString().split('T')[0]
            break
          case 'weekly':
            const weekStart = new Date(itemDate)
            weekStart.setDate(itemDate.getDate() - itemDate.getDay())
            timeKey = weekStart.toISOString().split('T')[0]
            break
          case 'monthly':
            timeKey = `${itemDate.getFullYear()}-${(itemDate.getMonth() + 1).toString().padStart(2, '0')}`
            break
          default:
            timeKey = itemDate.toISOString().split('T')[0]
        }
        
        if (result[timeKey]) {
          result[timeKey].push(item)
        }
      })
      
      return result
    }
    
    function getTimeAxisLabel(granularity) {
      switch (granularity) {
        case 'hourly': return 'Stunde'
        case 'daily': return 'Datum'
        case 'weekly': return 'Woche'
        case 'monthly': return 'Monat'
        default: return 'Datum'
      }
    }
    
    // Hilfsfunktionen
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
      return result ? 
        `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` 
        : '52, 152, 219'
    }
    
    function darkenColor(hex, factor = 0.2) {
      // Vereinfachte Funktion zum Abdunkeln einer Farbe
      let r = parseInt(hex.slice(1, 3), 16)
      let g = parseInt(hex.slice(3, 5), 16)
      let b = parseInt(hex.slice(5, 7), 16)
      
      r = Math.floor(r * (1 - factor))
      g = Math.floor(g * (1 - factor))
      b = Math.floor(b * (1 - factor))
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
    }
  </script>
</body>
</src/pages>